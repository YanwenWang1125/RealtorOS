name: Deploy to Azure Container Apps

on:
  push:
    branches:
      - main
      - staging
  workflow_dispatch:

env:
  RESOURCE_GROUP: realtoros-rg
  ACR_NAME: ${{ secrets.ACR_NAME }}
  BACKEND_APP_NAME: realtoros-backend
  FRONTEND_APP_NAME: realtoros-frontend
  BACKEND_IMAGE: ${{ secrets.ACR_NAME }}.azurecr.io/realtoros-api
  FRONTEND_IMAGE: ${{ secrets.ACR_NAME }}.azurecr.io/realtoros-frontend
  CONTAINER_ENV_NAME: realtoros-env
  LOCATION: canadacentral
  DB_SERVER_NAME: realtoros-db
  DB_NAME: realtoros
  DB_ADMIN_USER: postgres

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    env:
      # Application environment (non-sensitive, can be in workflow)
      ENVIRONMENT: test
      DEBUG: "true"
      API_TITLE: RealtorOS API
      API_VERSION: 1.0.0
      # Database (using in-memory SQLite for tests)
      DATABASE_URL: "sqlite+aiosqlite:///:memory:"
      # OpenAI (can use secrets.OPENAI_API_KEY if you want to test with real API)
      # Default test values will be set in a step if secrets are not provided
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_MODEL: ${{ secrets.OPENAI_MODEL }}
      OPENAI_MAX_TOKENS: "2000"
      # AWS SES (can use secrets if needed for integration tests)
      AWS_REGION: ${{ secrets.AWS_REGION }}
      SES_FROM_EMAIL: ${{ secrets.SES_FROM_EMAIL }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      # Logging
      LOG_LEVEL: INFO
      # Security (can use secrets.TEST_SECRET_KEY, defaults to test value)
      SECRET_KEY: ${{ secrets.TEST_SECRET_KEY }}
      ALGORITHM: HS256
      ACCESS_TOKEN_EXPIRE_MINUTES: "1440"
      # CORS
      CORS_ORIGINS: http://localhost:3000

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install backend dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-cov

      - name: Set test environment variables with defaults
        run: |
          # Set default test values if secrets are not provided
          # This allows using GitHub Secrets for real API keys when needed,
          # but falls back to test values for CI/CD
          echo "OPENAI_API_KEY=${OPENAI_API_KEY:-test-key}" >> $GITHUB_ENV
          echo "OPENAI_MODEL=${OPENAI_MODEL:-gpt-4}" >> $GITHUB_ENV
          echo "AWS_REGION=${AWS_REGION:-us-east-1}" >> $GITHUB_ENV
          echo "SES_FROM_EMAIL=${SES_FROM_EMAIL:-test@example.com}" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-test-key}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY:-test-secret}" >> $GITHUB_ENV
          echo "SECRET_KEY=${SECRET_KEY:-test-secret-key-minimum-32-characters-long}" >> $GITHUB_ENV

      - name: Run backend tests
        working-directory: ./backend
        run: |
          pytest tests/ -v --cov=app --cov-report=xml

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml
          flags: backend

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Ensure ACR admin user is enabled
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az acr update --name ${{ secrets.ACR_NAME }} --admin-enabled true

      - name: Get ACR credentials
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Get ACR login server
            ACR_LOGIN_SERVER=$(az acr show --name ${{ secrets.ACR_NAME }} --query loginServer --output tsv)
            echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
            
            # Get ACR credentials
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            
            # Export credentials for Docker login (outside this container)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Log in to Azure Container Registry with Docker
        run: |
          echo "$ACR_PASSWORD" | docker login $ACR_LOGIN_SERVER --username "$ACR_USERNAME" --password-stdin

      - name: Set image tags
        id: tags
        run: |
          echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:latest
            ${{ env.BACKEND_IMAGE }}:${{ steps.tags.outputs.SHORT_SHA }}
          labels: |
            org.opencontainers.image.created=${{ steps.tags.outputs.BUILD_DATE }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          tags: |
            ${{ env.FRONTEND_IMAGE }}:latest
            ${{ env.FRONTEND_IMAGE }}:${{ steps.tags.outputs.SHORT_SHA }}
          labels: |
            org.opencontainers.image.created=${{ steps.tags.outputs.BUILD_DATE }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache,mode=max

  provision-database:
    name: Provision PostgreSQL Database
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Verify PostgreSQL server exists
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Verifying PostgreSQL server exists..."
            if az postgres flexible-server show --name ${{ env.DB_SERVER_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "âœ… PostgreSQL server exists"
            else
              echo "âŒ ERROR: PostgreSQL server '${{ env.DB_SERVER_NAME }}' not found in resource group '${{ env.RESOURCE_GROUP }}'"
              echo "Please create the PostgreSQL Flexible Server manually before running this workflow"
              exit 1
            fi

      - name: Check if database exists
        id: check-database
        uses: azure/CLI@v1
        with:
          inlineScript: |
            if az postgres flexible-server db show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --server-name ${{ env.DB_SERVER_NAME }} \
              --database-name ${{ env.DB_NAME }} &>/dev/null; then
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "Database already exists"
            else
              echo "exists=false" >> $GITHUB_OUTPUT
              echo "Database does not exist, will create it"
            fi

      - name: Create database
        if: steps.check-database.outputs.exists == 'false'
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Creating database '${{ env.DB_NAME }}'..."
            az postgres flexible-server db create \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --server-name ${{ env.DB_SERVER_NAME }} \
              --database-name ${{ env.DB_NAME }} \
              --output table

      - name: Get database connection details
        id: db-connection
        uses: azure/CLI@v1
        with:
          inlineScript: |
            DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
            DB_USER="${{ env.DB_ADMIN_USER }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            DB_NAME="${{ env.DB_NAME }}"
            
            # Construct DATABASE_URL
            DATABASE_URL="postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}"
            
            echo "DATABASE_URL=${DATABASE_URL}" >> $GITHUB_ENV
            echo "DB_HOST=${DB_HOST}" >> $GITHUB_ENV
            
            echo "Database connection details:"
            echo "  Host: ${DB_HOST}"
            echo "  Database: ${DB_NAME}"
            echo "  User: ${DB_USER}"
            echo ""
            echo "âš ï¸  IMPORTANT: Update your GitHub secret 'DATABASE_URL' with the following value:"
            echo "${DATABASE_URL}"

      - name: Verify database connectivity
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Verifying database server is accessible..."
            DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
            
            # Check if we can resolve the hostname
            if nslookup ${DB_HOST} &>/dev/null; then
              echo "âœ… Database hostname resolves: ${DB_HOST}"
            else
              echo "âš ï¸  Warning: Cannot resolve hostname ${DB_HOST}"
              echo "This may be normal if DNS hasn't propagated yet"
            fi

  run-migrations:
    name: Run Alembic Migrations
    runs-on: ubuntu-latest
    needs: [build-and-push, provision-database]

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get ACR login server
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_LOGIN_SERVER=$(az acr show --name ${{ secrets.ACR_NAME }} --query loginServer --output tsv)
            echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV

      - name: Get ACR credentials
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Construct DATABASE_URL from DB_PASSWORD
        id: db-url
        run: |
          # Build DATABASE_URL from DB_PASSWORD secret
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "âŒ ERROR: DB_PASSWORD secret is not set!"
            echo "Please set DB_PASSWORD secret in GitHub Secrets"
            exit 1
          fi
          
          # Construct DATABASE_URL from database server details
          DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
          DB_USER="${{ env.DB_ADMIN_USER }}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          DB_NAME="${{ env.DB_NAME }}"
          DATABASE_URL="postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}"
          
          echo "âœ… Constructed DATABASE_URL from database server details"
          echo "Database host: ${DB_HOST}"
          echo "Database name: ${DB_NAME}"
          echo "Database user: ${DB_USER}"
          
          # Show masked DATABASE_URL for debugging (mask password)
          DB_URL_MASKED=$(echo "${DATABASE_URL}" | sed -E 's|://([^:]+):[^@]+@|://\1:***@|')
          echo "DATABASE_URL (masked): ${DB_URL_MASKED}"
          
          echo "DATABASE_URL=${DATABASE_URL}" >> $GITHUB_ENV

      - name: Run Alembic migrations
        run: |
          echo "Running Alembic migrations..."
          echo "${{ env.ACR_PASSWORD }}" | docker login ${{ env.ACR_LOGIN_SERVER }} --username "${{ env.ACR_USERNAME }}" --password-stdin
          docker run --rm \
            -e ENVIRONMENT=production \
            -e DEBUG=false \
            -e API_TITLE="RealtorOS API" \
            -e API_VERSION="1.0.0" \
            -e DATABASE_URL="${{ env.DATABASE_URL }}" \
            -e OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            -e OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}" \
            -e OPENAI_MAX_TOKENS="2000" \
            -e AWS_REGION="${{ secrets.AWS_REGION }}" \
            -e SES_FROM_EMAIL="${{ secrets.SES_FROM_EMAIL }}" \
            -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -e SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            -e ALGORITHM="HS256" \
            -e ACCESS_TOKEN_EXPIRE_MINUTES="1440" \
            -e LOG_LEVEL=INFO \
            -e CORS_ORIGINS="${{ secrets.CORS_ORIGINS }}" \
            ${{ env.BACKEND_IMAGE }}:latest \
            alembic upgrade head

  deploy-backend:
    name: Deploy Backend to Azure
    runs-on: ubuntu-latest
    needs: [build-and-push, provision-database, run-migrations]

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check if Container App environment exists
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Check if container app environment exists
            if ! az containerapp env show --name ${{ env.CONTAINER_ENV_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "Creating Container App environment..."
              az containerapp env create \
                --name ${{ env.CONTAINER_ENV_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --location ${{ env.LOCATION }}
            else
              echo "Container App environment already exists"
            fi

      - name: Get ACR credentials for deployment
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Deploy backend to Container Apps
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Construct DATABASE_URL from DB_PASSWORD secret
            if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
              echo "âŒ ERROR: DB_PASSWORD secret is not set!"
              echo "Please set DB_PASSWORD secret in GitHub Secrets"
              exit 1
            fi
            
            # Construct DATABASE_URL from database server details
            DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
            DB_USER="${{ env.DB_ADMIN_USER }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            DB_NAME="${{ env.DB_NAME }}"
            DATABASE_URL="postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}"
            echo "âœ… Constructed DATABASE_URL from database server details"
            echo "Database: ${DB_HOST}/${DB_NAME}"
            
            # Check if backend container app exists
            if az containerapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "Updating existing backend container app..."
              az containerapp update \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --image ${{ env.BACKEND_IMAGE }}:latest \
                --min-replicas 0 \
                --set-env-vars \
                  ENVIRONMENT=production \
                  DEBUG=false \
                  API_TITLE="RealtorOS API" \
                  API_VERSION="1.0.0" \
                  DATABASE_URL="${DATABASE_URL}" \
                  OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
                  OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}" \
                  OPENAI_MAX_TOKENS="2000" \
                  AWS_REGION="${{ secrets.AWS_REGION }}" \
                  SES_FROM_EMAIL="${{ secrets.SES_FROM_EMAIL }}" \
                  AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
                  AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                  SECRET_KEY="${{ secrets.SECRET_KEY }}" \
                  ALGORITHM="HS256" \
                  ACCESS_TOKEN_EXPIRE_MINUTES="1440" \
                  LOG_LEVEL=INFO \
                  CORS_ORIGINS="${{ secrets.CORS_ORIGINS }}"
            else
              echo "Creating new backend container app..."
              az containerapp create \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --environment ${{ env.CONTAINER_ENV_NAME }} \
                --image ${{ env.BACKEND_IMAGE }}:latest \
                --registry-server ${{ secrets.ACR_NAME }}.azurecr.io \
                --registry-username $ACR_USERNAME \
                --registry-password $ACR_PASSWORD \
                --target-port 8000 \
                --ingress external \
                --min-replicas 0 \
                --max-replicas 10 \
                --cpu 0.5 \
                --memory 1.0Gi \
                --env-vars \
                  ENVIRONMENT=production \
                  DEBUG=false \
                  API_TITLE="RealtorOS API" \
                  API_VERSION="1.0.0" \
                  DATABASE_URL="${DATABASE_URL}" \
                  OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
                  OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}" \
                  OPENAI_MAX_TOKENS="2000" \
                  AWS_REGION="${{ secrets.AWS_REGION }}" \
                  SES_FROM_EMAIL="${{ secrets.SES_FROM_EMAIL }}" \
                  AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
                  AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                  SECRET_KEY="${{ secrets.SECRET_KEY }}" \
                  ALGORITHM="HS256" \
                  ACCESS_TOKEN_EXPIRE_MINUTES="1440" \
                  LOG_LEVEL=INFO \
                  CORS_ORIGINS="${{ secrets.CORS_ORIGINS }}"
            fi

  deploy-frontend:
    name: Deploy Frontend to Azure
    runs-on: ubuntu-latest
    needs: deploy-backend

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get backend URL for frontend
        id: backend-url
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Wait for backend container app to be ready
            echo "Waiting for backend container app to be ready..."
            for i in {1..30}; do
              if az containerapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
                BACKEND_URL=$(az containerapp show \
                  --name ${{ env.BACKEND_APP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --query properties.configuration.ingress.fqdn -o tsv)
                if [ -n "$BACKEND_URL" ] && [ "$BACKEND_URL" != "null" ]; then
                  echo "Backend URL: $BACKEND_URL"
                  echo "url=https://$BACKEND_URL" >> $GITHUB_OUTPUT
                  exit 0
                fi
              fi
              echo "Attempt $i/30: Backend not ready yet, waiting..."
              sleep 5
            done
            echo "ERROR: Backend container app not found or not ready"
            exit 1

      - name: Get ACR credentials for deployment
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Deploy frontend to Container Apps
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Check if frontend container app exists
            if az containerapp show --name ${{ env.FRONTEND_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "Updating existing frontend container app..."
              az containerapp update \
                --name ${{ env.FRONTEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --image ${{ env.FRONTEND_IMAGE }}:latest \
                --min-replicas 0 \
                --set-env-vars NEXT_PUBLIC_API_URL=${{ steps.backend-url.outputs.url }}
            else
              echo "Creating new frontend container app..."
              az containerapp create \
                --name ${{ env.FRONTEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --environment ${{ env.CONTAINER_ENV_NAME }} \
                --image ${{ env.FRONTEND_IMAGE }}:latest \
                --registry-server ${{ secrets.ACR_NAME }}.azurecr.io \
                --registry-username $ACR_USERNAME \
                --registry-password $ACR_PASSWORD \
                --target-port 3000 \
                --ingress external \
                --min-replicas 0 \
                --max-replicas 10 \
                --cpu 0.25 \
                --memory 0.5Gi \
                --env-vars \
                  NEXT_PUBLIC_API_URL=${{ steps.backend-url.outputs.url }}
            fi

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get backend URL
        id: backend-url
        uses: azure/CLI@v1
        with:
          inlineScript: |
            BACKEND_URL=$(az containerapp show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query properties.configuration.ingress.fqdn -o tsv)
            echo "url=https://$BACKEND_URL" >> $GITHUB_OUTPUT

      - name: Get frontend URL
        id: frontend-url
        uses: azure/CLI@v1
        with:
          inlineScript: |
            FRONTEND_URL=$(az containerapp show \
              --name ${{ env.FRONTEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query properties.configuration.ingress.fqdn -o tsv)
            echo "url=https://$FRONTEND_URL" >> $GITHUB_OUTPUT

      - name: Scale up backend for health check
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Ensuring backend container is scaled up..."
            az containerapp update \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --min-replicas 1 \
              --max-replicas 10 || echo "Could not update scale settings"
            echo "Waiting 30 seconds for container to start..."
            sleep 30

      - name: Wait for backend to be ready
        run: |
          echo "Waiting for backend container to be ready..."
          BACKEND_URL="${{ steps.backend-url.outputs.url }}"
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking backend health..."
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$BACKEND_URL/health" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Backend is healthy!"
              curl -s "$BACKEND_URL/health" | head -20
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "âš ï¸  Connection failed (container may still be starting)..."
            else
              echo "âš ï¸  Got HTTP $HTTP_CODE (container may still be starting)..."
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 10
            fi
          done
          
          echo "âŒ Backend health check failed after $MAX_ATTEMPTS attempts"
          echo "Checking container logs..."
          exit 1

      - name: Check backend container logs on failure
        if: failure()
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "=== Backend Container Logs (last 50 lines) ==="
            az containerapp logs show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --tail 50 || echo "Could not retrieve logs"
            
            echo ""
            echo "=== Backend Container Status ==="
            az containerapp show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "{provisioningState:properties.provisioningState,latestRevisionName:properties.latestRevisionName,replicas:properties.template.scale}" \
              --output table || echo "Could not retrieve status"

      - name: Check frontend health
        run: |
          echo "Checking frontend health..."
          FRONTEND_URL="${{ steps.frontend-url.outputs.url }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking frontend..."
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$FRONTEND_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "304" ]; then
              echo "âœ… Frontend is healthy!"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "âš ï¸  Connection failed (container may still be starting)..."
            else
              echo "âš ï¸  Got HTTP $HTTP_CODE (container may still be starting)..."
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 10
            fi
          done
          
          echo "âŒ Frontend health check failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Deployment summary
        run: |
          echo "### Deployment Successful! ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Backend URL:** ${{ steps.backend-url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend URL:** ${{ steps.frontend-url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**API Docs:** ${{ steps.backend-url.outputs.url }}/docs" >> $GITHUB_STEP_SUMMARY
