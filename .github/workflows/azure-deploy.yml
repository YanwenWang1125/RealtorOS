name: Deploy to Azure Container Apps

on:
  push:
    branches:
      - main
      - staging
  workflow_dispatch:

env:
  RESOURCE_GROUP: realtoros-rg
  ACR_NAME: ${{ secrets.ACR_NAME }}
  BACKEND_APP_NAME: realtoros-backend
  FRONTEND_APP_NAME: realtoros-frontend
  BACKEND_IMAGE: ${{ secrets.ACR_NAME }}.azurecr.io/realtoros-api
  FRONTEND_IMAGE: ${{ secrets.ACR_NAME }}.azurecr.io/realtoros-frontend
  CONTAINER_ENV_NAME: realtoros-env
  # LOCATION is used when creating new Container App environments
  # If the environment already exists, this setting won't affect it
  # Note: If database is in a different region, there will be cross-region latency (~50-100ms)
  # but functionality will work normally. For best performance, keep all resources in the same region.
  LOCATION: canadacentral
  DB_SERVER_NAME: realtoros-db
  DB_NAME: realtoros
  DB_ADMIN_USER: postgres

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    env:
      # Application environment (non-sensitive, can be in workflow)
      ENVIRONMENT: test
      DEBUG: "true"
      API_TITLE: RealtorOS API
      API_VERSION: 1.0.0
      # Database (using in-memory SQLite for tests)
      DATABASE_URL: "sqlite+aiosqlite:///:memory:"
      # OpenAI (can use secrets.OPENAI_API_KEY if you want to test with real API)
      # Default test values will be set in a step if secrets are not provided
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_MODEL: ${{ secrets.OPENAI_MODEL }}
      OPENAI_MAX_TOKENS: "2000"
      # AWS SES (can use secrets if needed for integration tests)
      AWS_REGION: ${{ secrets.AWS_REGION }}
      SES_FROM_EMAIL: ${{ secrets.SES_FROM_EMAIL }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      # Logging
      LOG_LEVEL: INFO
      # Security (can use secrets.TEST_SECRET_KEY, defaults to test value)
      SECRET_KEY: ${{ secrets.TEST_SECRET_KEY }}
      ALGORITHM: HS256
      ACCESS_TOKEN_EXPIRE_MINUTES: "1440"
      # CORS
      CORS_ORIGINS: http://localhost:3000

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install backend dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-cov

      - name: Set test environment variables with defaults
        run: |
          # Set default test values if secrets are not provided
          # This allows using GitHub Secrets for real API keys when needed,
          # but falls back to test values for CI/CD
          echo "OPENAI_API_KEY=${OPENAI_API_KEY:-test-key}" >> $GITHUB_ENV
          echo "OPENAI_MODEL=${OPENAI_MODEL:-gpt-4}" >> $GITHUB_ENV
          echo "AWS_REGION=${AWS_REGION:-us-east-1}" >> $GITHUB_ENV
          echo "SES_FROM_EMAIL=${SES_FROM_EMAIL:-test@example.com}" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-test-key}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY:-test-secret}" >> $GITHUB_ENV
          echo "SECRET_KEY=${SECRET_KEY:-test-secret-key-minimum-32-characters-long}" >> $GITHUB_ENV

      - name: Run backend tests
        working-directory: ./backend
        run: |
          pytest tests/ -v --cov=app --cov-report=xml

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml
          flags: backend

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Ensure ACR admin user is enabled
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az acr update --name ${{ secrets.ACR_NAME }} --admin-enabled true

      - name: Get ACR credentials
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Get ACR login server
            ACR_LOGIN_SERVER=$(az acr show --name ${{ secrets.ACR_NAME }} --query loginServer --output tsv)
            echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
            
            # Get ACR credentials
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            
            # Export credentials for Docker login (outside this container)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Log in to Azure Container Registry with Docker
        run: |
          echo "$ACR_PASSWORD" | docker login $ACR_LOGIN_SERVER --username "$ACR_USERNAME" --password-stdin

      - name: Set image tags
        id: tags
        run: |
          echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:latest
            ${{ env.BACKEND_IMAGE }}:${{ steps.tags.outputs.SHORT_SHA }}
          labels: |
            org.opencontainers.image.created=${{ steps.tags.outputs.BUILD_DATE }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          # Note: NEXT_PUBLIC_API_URL is intentionally not set here (or set to empty)
          # The frontend code now uses relative paths (/api) which are proxied by Next.js rewrites
          # The rewrites function in next.config.mjs reads NEXT_PUBLIC_API_URL at server startup (runtime)
          # This allows the backend URL to be configured via container app environment variables
          build-args: |
            NEXT_PUBLIC_API_URL=
          tags: |
            ${{ env.FRONTEND_IMAGE }}:latest
            ${{ env.FRONTEND_IMAGE }}:${{ steps.tags.outputs.SHORT_SHA }}
          labels: |
            org.opencontainers.image.created=${{ steps.tags.outputs.BUILD_DATE }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache,mode=max

  provision-database:
    name: Provision PostgreSQL Database
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Verify PostgreSQL server exists
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Verifying PostgreSQL server exists..."
            if az postgres flexible-server show --name ${{ env.DB_SERVER_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "âœ… PostgreSQL server exists"
            else
              echo "âŒ ERROR: PostgreSQL server '${{ env.DB_SERVER_NAME }}' not found in resource group '${{ env.RESOURCE_GROUP }}'"
              echo "Please create the PostgreSQL Flexible Server manually before running this workflow"
              exit 1
            fi

      - name: Check if database exists
        id: check-database
        uses: azure/CLI@v1
        with:
          inlineScript: |
            if az postgres flexible-server db show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --server-name ${{ env.DB_SERVER_NAME }} \
              --database-name ${{ env.DB_NAME }} &>/dev/null; then
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "Database already exists"
            else
              echo "exists=false" >> $GITHUB_OUTPUT
              echo "Database does not exist, will create it"
            fi

      - name: Create database
        if: steps.check-database.outputs.exists == 'false'
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Creating database '${{ env.DB_NAME }}'..."
            az postgres flexible-server db create \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --server-name ${{ env.DB_SERVER_NAME }} \
              --database-name ${{ env.DB_NAME }} \
              --output table

      - name: Get database connection details
        id: db-connection
        uses: azure/CLI@v1
        with:
          inlineScript: |
            DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
            DB_USER="${{ env.DB_ADMIN_USER }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            DB_NAME="${{ env.DB_NAME }}"
            
            # Construct DATABASE_URL
            DATABASE_URL="postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}"
            
            echo "DATABASE_URL=${DATABASE_URL}" >> $GITHUB_ENV
            echo "DB_HOST=${DB_HOST}" >> $GITHUB_ENV
            
            echo "Database connection details:"
            echo "  Host: ${DB_HOST}"
            echo "  Database: ${DB_NAME}"
            echo "  User: ${DB_USER}"
            echo ""
            echo "âš ï¸  IMPORTANT: Update your GitHub secret 'DATABASE_URL' with the following value:"
            echo "${DATABASE_URL}"

      - name: Verify database connectivity
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Verifying database server is accessible..."
            DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
            
            # Check if we can resolve the hostname
            if nslookup ${DB_HOST} &>/dev/null; then
              echo "âœ… Database hostname resolves: ${DB_HOST}"
            else
              echo "âš ï¸  Warning: Cannot resolve hostname ${DB_HOST}"
              echo "This may be normal if DNS hasn't propagated yet"
            fi

  run-migrations:
    name: Run Alembic Migrations
    runs-on: ubuntu-latest
    needs: [build-and-push, provision-database]

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get ACR login server
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_LOGIN_SERVER=$(az acr show --name ${{ secrets.ACR_NAME }} --query loginServer --output tsv)
            echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV

      - name: Get ACR credentials
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Construct DATABASE_URL from DB_PASSWORD
        id: db-url
        run: |
          # Build DATABASE_URL from DB_PASSWORD secret
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "âŒ ERROR: DB_PASSWORD secret is not set!"
            echo "Please set DB_PASSWORD secret in GitHub Secrets"
            exit 1
          fi
          
          # Construct DATABASE_URL from database server details
          DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
          DB_USER="${{ env.DB_ADMIN_USER }}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          DB_NAME="${{ env.DB_NAME }}"
          DATABASE_URL="postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}"
          
          echo "âœ… Constructed DATABASE_URL from database server details"
          echo "Database host: ${DB_HOST}"
          echo "Database name: ${DB_NAME}"
          echo "Database user: ${DB_USER}"
          
          # Show masked DATABASE_URL for debugging (mask password)
          DB_URL_MASKED=$(echo "${DATABASE_URL}" | sed -E 's|://([^:]+):[^@]+@|://\1:***@|')
          echo "DATABASE_URL (masked): ${DB_URL_MASKED}"
          
          echo "DATABASE_URL=${DATABASE_URL}" >> $GITHUB_ENV

      - name: Run Alembic migrations
        run: |
          echo "Running Alembic migrations..."
          echo "${{ env.ACR_PASSWORD }}" | docker login ${{ env.ACR_LOGIN_SERVER }} --username "${{ env.ACR_USERNAME }}" --password-stdin
          
          # Set CORS_ORIGINS for migration (not critical, just needs a valid value)
          if [ -n "${{ secrets.CORS_ORIGINS }}" ] && [ "${{ secrets.CORS_ORIGINS }}" != "" ]; then
            CORS_VALUE="${{ secrets.CORS_ORIGINS }}"
          else
            CORS_VALUE="https://realtoros-frontend.${{ env.LOCATION }}.azurecontainerapps.io"
          fi
          
          docker run --rm \
            -e ENVIRONMENT=production \
            -e DEBUG=false \
            -e API_TITLE="RealtorOS API" \
            -e API_VERSION="1.0.0" \
            -e DATABASE_URL="${{ env.DATABASE_URL }}" \
            -e OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            -e OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}" \
            -e OPENAI_MAX_TOKENS="2000" \
            -e AWS_REGION="${{ secrets.AWS_REGION }}" \
            -e SES_FROM_EMAIL="${{ secrets.SES_FROM_EMAIL }}" \
            -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -e SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            -e ALGORITHM="HS256" \
            -e ACCESS_TOKEN_EXPIRE_MINUTES="1440" \
            -e LOG_LEVEL=INFO \
            -e CORS_ORIGINS="${CORS_VALUE}" \
            ${{ env.BACKEND_IMAGE }}:latest \
            alembic upgrade head

  deploy-backend:
    name: Deploy Backend to Azure
    runs-on: ubuntu-latest
    needs: [build-and-push, provision-database, run-migrations]

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check and create Container App environment in correct region
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Check if container app environment exists
            if ! az containerapp env show --name ${{ env.CONTAINER_ENV_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "Creating Container App environment in ${{ env.LOCATION }}..."
              az containerapp env create \
                --name ${{ env.CONTAINER_ENV_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --location ${{ env.LOCATION }}
            else
              # Check if environment is in the correct region
              ENV_LOCATION=$(az containerapp env show \
                --name ${{ env.CONTAINER_ENV_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --query location -o tsv)
              
              if [ "$ENV_LOCATION" != "${{ env.LOCATION }}" ]; then
                echo "âš ï¸  WARNING: Container App environment exists in $ENV_LOCATION, but desired location is ${{ env.LOCATION }}"
                echo "âš ï¸  Container Apps Environment cannot be migrated. You need to:"
                echo "   1. Delete existing container apps (backend and frontend)"
                echo "   2. Delete the existing environment"
                echo "   3. Re-run this workflow to create environment in ${{ env.LOCATION }}"
                echo "   Or use the migration script: deploy/scripts/migrate-to-canadacentral.sh"
                exit 1
              else
                echo "âœ… Container App environment exists in correct region: $ENV_LOCATION"
              fi
            fi

      - name: Get ACR credentials for deployment
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Deploy backend to Container Apps
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Construct DATABASE_URL from DB_PASSWORD secret
            if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
              echo "âŒ ERROR: DB_PASSWORD secret is not set!"
              echo "Please set DB_PASSWORD secret in GitHub Secrets"
              exit 1
            fi
            
            # Construct DATABASE_URL from database server details
            DB_HOST="${{ env.DB_SERVER_NAME }}.postgres.database.azure.com"
            DB_USER="${{ env.DB_ADMIN_USER }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            DB_NAME="${{ env.DB_NAME }}"
            DATABASE_URL="postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}"
            echo "âœ… Constructed DATABASE_URL from database server details"
            echo "Database: ${DB_HOST}/${DB_NAME}"
            
            # Check if backend container app exists
            if az containerapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "Updating existing backend container app..."
              # Remove old AWS_SES_* variables if they exist (they should use AWS_ACCESS_KEY_ID instead)
              az containerapp update \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --remove-env-vars AWS_SES_ACCESS_KEY_ID AWS_SES_SECRET_ACCESS_KEY 2>/dev/null || echo "Old AWS_SES_* variables not found (or already removed)"
              
              # Get current CORS_ORIGINS to preserve it if secret is not set
              CURRENT_CORS=$(az containerapp show \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --query "properties.template.containers[0].env[?name=='CORS_ORIGINS'].value" -o tsv)
              
              # Use secret if available, otherwise keep current value (will be updated by auto-update step)
              if [ -n "${{ secrets.CORS_ORIGINS }}" ] && [ "${{ secrets.CORS_ORIGINS }}" != "" ]; then
                CORS_VALUE="${{ secrets.CORS_ORIGINS }}"
              else
                CORS_VALUE="${CURRENT_CORS:-https://realtoros-frontend.${{ env.LOCATION }}.azurecontainerapps.io}"
              fi
              
              # Update with correct environment variables
              az containerapp update \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --image ${{ env.BACKEND_IMAGE }}:latest \
                --min-replicas 0 \
                --set-env-vars \
                  ENVIRONMENT=production \
                  DEBUG=false \
                  API_TITLE="RealtorOS API" \
                  API_VERSION="1.0.0" \
                  DATABASE_URL="${DATABASE_URL}" \
                  OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
                  OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}" \
                  OPENAI_MAX_TOKENS="2000" \
                  AWS_REGION="${{ secrets.AWS_REGION }}" \
                  SES_FROM_EMAIL="${{ secrets.SES_FROM_EMAIL }}" \
                  AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
                  AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                  GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}" \
                  GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}" \
                  SECRET_KEY="${{ secrets.SECRET_KEY }}" \
                  ALGORITHM="HS256" \
                  ACCESS_TOKEN_EXPIRE_MINUTES="1440" \
                  LOG_LEVEL=INFO \
                  CORS_ORIGINS="${CORS_VALUE}"
            else
              echo "Creating new backend container app..."
              # Use placeholder CORS_ORIGINS if secret is not set - will be updated automatically after frontend deployment
              CORS_PLACEHOLDER="https://realtoros-frontend.${{ env.LOCATION }}.azurecontainerapps.io"
              if [ -n "${{ secrets.CORS_ORIGINS }}" ] && [ "${{ secrets.CORS_ORIGINS }}" != "" ]; then
                CORS_INITIAL_VALUE="${{ secrets.CORS_ORIGINS }}"
              else
                CORS_INITIAL_VALUE="$CORS_PLACEHOLDER"
              fi
              echo "Using CORS_ORIGINS: $CORS_INITIAL_VALUE (will be updated to actual frontend URL after deployment)"
              
              az containerapp create \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --environment ${{ env.CONTAINER_ENV_NAME }} \
                --image ${{ env.BACKEND_IMAGE }}:latest \
                --registry-server ${{ secrets.ACR_NAME }}.azurecr.io \
                --registry-username $ACR_USERNAME \
                --registry-password $ACR_PASSWORD \
                --target-port 8000 \
                --ingress external \
                --min-replicas 0 \
                --max-replicas 10 \
                --cpu 0.5 \
                --memory 1.0Gi \
                --env-vars \
                  ENVIRONMENT=production \
                  DEBUG=false \
                  API_TITLE="RealtorOS API" \
                  API_VERSION="1.0.0" \
                  DATABASE_URL="${DATABASE_URL}" \
                  OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
                  OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}" \
                  OPENAI_MAX_TOKENS="2000" \
                  AWS_REGION="${{ secrets.AWS_REGION }}" \
                  SES_FROM_EMAIL="${{ secrets.SES_FROM_EMAIL }}" \
                  AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
                  AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                  GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}" \
                  GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}" \
                  SECRET_KEY="${{ secrets.SECRET_KEY }}" \
                  ALGORITHM="HS256" \
                  ACCESS_TOKEN_EXPIRE_MINUTES="1440" \
                  LOG_LEVEL=INFO \
                  CORS_ORIGINS="${CORS_INITIAL_VALUE}"
            fi

  deploy-frontend:
    name: Deploy Frontend to Azure
    runs-on: ubuntu-latest
    needs: deploy-backend

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get backend URL for frontend
        id: backend-url
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Wait for backend container app to be ready and get its URL
            echo "Waiting for backend container app to be ready..."
            MAX_ATTEMPTS=30
            ATTEMPT=0
            
            while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
              ATTEMPT=$((ATTEMPT + 1))
              
              if az containerapp show --name ${{ env.BACKEND_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
                BACKEND_URL=$(az containerapp show \
                  --name ${{ env.BACKEND_APP_NAME }} \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --query properties.configuration.ingress.fqdn -o tsv)
                
                if [ -n "$BACKEND_URL" ] && [ "$BACKEND_URL" != "null" ] && [ "$BACKEND_URL" != "" ]; then
                  echo "âœ… Backend URL retrieved: $BACKEND_URL"
                  echo "url=https://$BACKEND_URL" >> $GITHUB_OUTPUT
                  echo "fqdn=$BACKEND_URL" >> $GITHUB_OUTPUT
                  exit 0
                else
                  echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Backend FQDN not available yet..."
                fi
              else
                echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Backend container app not found yet..."
              fi
              
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                sleep 5
              fi
            done
            
            echo "âŒ ERROR: Backend container app not found or FQDN not available after $MAX_ATTEMPTS attempts"
            echo "Trying to get more information..."
            az containerapp show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "{provisioningState:properties.provisioningState,ingress:properties.configuration.ingress}" \
              --output json || echo "Could not retrieve container app details"
            exit 1

      - name: Get ACR credentials for deployment
        uses: azure/CLI@v1
        with:
          inlineScript: |
            ACR_USERNAME=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query username --output tsv)
            ACR_PASSWORD=$(az acr credential show --name ${{ secrets.ACR_NAME }} --query 'passwords[0].value' --output tsv)
            echo "ACR_USERNAME=$ACR_USERNAME" >> $GITHUB_ENV
            echo "ACR_PASSWORD=$ACR_PASSWORD" >> $GITHUB_ENV

      - name: Verify backend URL before deployment
        run: |
          BACKEND_URL="${{ steps.backend-url.outputs.url }}"
          if [ -z "$BACKEND_URL" ] || [ "$BACKEND_URL" = "" ]; then
            echo "âŒ ERROR: Backend URL is empty!"
            exit 1
          fi
          echo "âœ… Backend URL verified: $BACKEND_URL"
          echo "This URL will be set as NEXT_PUBLIC_API_URL in the frontend container app"

      - name: Deploy frontend to Container Apps
        uses: azure/CLI@v1
        with:
          inlineScript: |
            BACKEND_URL="${{ steps.backend-url.outputs.url }}"
            
            if [ -z "$BACKEND_URL" ] || [ "$BACKEND_URL" = "" ]; then
              echo "âŒ ERROR: Backend URL is not available!"
              exit 1
            fi
            
            echo "Deploying frontend with backend URL: $BACKEND_URL"
            
            # Check if frontend container app exists
            if az containerapp show --name ${{ env.FRONTEND_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
              echo "Updating existing frontend container app..."
              az containerapp update \
                --name ${{ env.FRONTEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --image ${{ env.FRONTEND_IMAGE }}:latest \
                --min-replicas 0 \
                --set-env-vars \
                  NEXT_PUBLIC_API_URL="$BACKEND_URL" \
                  NEXT_PUBLIC_GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
              
              echo "âœ… Frontend container app updated successfully"
              echo "NEXT_PUBLIC_API_URL set to: $BACKEND_URL"
            else
              echo "Creating new frontend container app..."
              az containerapp create \
                --name ${{ env.FRONTEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --environment ${{ env.CONTAINER_ENV_NAME }} \
                --image ${{ env.FRONTEND_IMAGE }}:latest \
                --registry-server ${{ secrets.ACR_NAME }}.azurecr.io \
                --registry-username $ACR_USERNAME \
                --registry-password $ACR_PASSWORD \
                --target-port 3000 \
                --ingress external \
                --min-replicas 0 \
                --max-replicas 10 \
                --cpu 0.25 \
                --memory 0.5Gi \
                --env-vars \
                  NEXT_PUBLIC_API_URL="$BACKEND_URL" \
                  NEXT_PUBLIC_GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
              
              echo "âœ… Frontend container app created successfully"
              echo "NEXT_PUBLIC_API_URL set to: $BACKEND_URL"
            fi
            
            # Verify the environment variable was set correctly
            echo ""
            echo "Verifying environment variables..."
            ACTUAL_API_URL=$(az containerapp show \
              --name ${{ env.FRONTEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "properties.template.containers[0].env[?name=='NEXT_PUBLIC_API_URL'].value" -o tsv)
            
            if [ "$ACTUAL_API_URL" = "$BACKEND_URL" ]; then
              echo "âœ… NEXT_PUBLIC_API_URL verified: $ACTUAL_API_URL"
            else
              echo "âš ï¸  WARNING: NEXT_PUBLIC_API_URL mismatch!"
              echo "  Expected: $BACKEND_URL"
              echo "  Actual: $ACTUAL_API_URL"
            fi

      - name: Get frontend URL and update backend CORS_ORIGINS
        uses: azure/CLI@v1
        with:
          inlineScript: |
            # Get frontend URL
            FRONTEND_URL=$(az containerapp show \
              --name ${{ env.FRONTEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query properties.configuration.ingress.fqdn -o tsv)
            
            if [ -z "$FRONTEND_URL" ] || [ "$FRONTEND_URL" = "" ]; then
              echo "âš ï¸  WARNING: Could not get frontend URL. CORS_ORIGINS will use GitHub Secret value."
              exit 0
            fi
            
            FRONTEND_FULL_URL="https://$FRONTEND_URL"
            echo "Frontend URL: $FRONTEND_FULL_URL"
            
            # Get current CORS_ORIGINS from backend
            CURRENT_CORS=$(az containerapp show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "properties.template.containers[0].env[?name=='CORS_ORIGINS'].value" -o tsv)
            
            # Build new CORS_ORIGINS: use frontend URL, append any additional origins from secret if provided
            if [ -n "${{ secrets.CORS_ORIGINS }}" ] && [ "${{ secrets.CORS_ORIGINS }}" != "" ]; then
              # If secret exists, combine frontend URL with secret values (comma-separated)
              NEW_CORS_ORIGINS="$FRONTEND_FULL_URL,${{ secrets.CORS_ORIGINS }}"
              # Remove duplicates
              NEW_CORS_ORIGINS=$(echo "$NEW_CORS_ORIGINS" | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')
            else
              # If no secret, just use frontend URL
              NEW_CORS_ORIGINS="$FRONTEND_FULL_URL"
            fi
            
            # Only update if CORS_ORIGINS has changed
            if [ "$CURRENT_CORS" != "$NEW_CORS_ORIGINS" ]; then
              echo "Updating backend CORS_ORIGINS..."
              echo "  Old: $CURRENT_CORS"
              echo "  New: $NEW_CORS_ORIGINS"
              
              # Get all current environment variables
              az containerapp update \
                --name ${{ env.BACKEND_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --set-env-vars \
                  CORS_ORIGINS="$NEW_CORS_ORIGINS" \
                --output table
              
              echo "âœ… Backend CORS_ORIGINS updated successfully"
            else
              echo "âœ… Backend CORS_ORIGINS is already correct: $NEW_CORS_ORIGINS"
            fi

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]

    steps:
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get backend URL
        id: backend-url
        uses: azure/CLI@v1
        with:
          inlineScript: |
            BACKEND_URL=$(az containerapp show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query properties.configuration.ingress.fqdn -o tsv)
            echo "url=https://$BACKEND_URL" >> $GITHUB_OUTPUT

      - name: Get frontend URL
        id: frontend-url
        uses: azure/CLI@v1
        with:
          inlineScript: |
            FRONTEND_URL=$(az containerapp show \
              --name ${{ env.FRONTEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query properties.configuration.ingress.fqdn -o tsv)
            echo "url=https://$FRONTEND_URL" >> $GITHUB_OUTPUT

      - name: Scale up backend for health check
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "Ensuring backend container is scaled up..."
            az containerapp update \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --min-replicas 1 \
              --max-replicas 10 || echo "Could not update scale settings"
            echo "Waiting 30 seconds for container to start..."
            sleep 30

      - name: Wait for backend to be ready
        run: |
          echo "Waiting for backend container to be ready..."
          BACKEND_URL="${{ steps.backend-url.outputs.url }}"
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking backend health..."
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$BACKEND_URL/health" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Backend is healthy!"
              curl -s "$BACKEND_URL/health" | head -20
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "âš ï¸  Connection failed (container may still be starting)..."
            else
              echo "âš ï¸  Got HTTP $HTTP_CODE (container may still be starting)..."
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 10
            fi
          done
          
          echo "âŒ Backend health check failed after $MAX_ATTEMPTS attempts"
          echo "Checking container logs..."
          exit 1

      - name: Check backend container logs on failure
        if: failure()
        uses: azure/CLI@v1
        with:
          inlineScript: |
            echo "=== Backend Container Logs (last 50 lines) ==="
            az containerapp logs show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --tail 50 || echo "Could not retrieve logs"
            
            echo ""
            echo "=== Backend Container Status ==="
            az containerapp show \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "{provisioningState:properties.provisioningState,latestRevisionName:properties.latestRevisionName,replicas:properties.template.scale}" \
              --output table || echo "Could not retrieve status"

      - name: Check frontend health
        run: |
          echo "Checking frontend health..."
          FRONTEND_URL="${{ steps.frontend-url.outputs.url }}"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking frontend..."
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$FRONTEND_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "304" ]; then
              echo "âœ… Frontend is healthy!"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "âš ï¸  Connection failed (container may still be starting)..."
            else
              echo "âš ï¸  Got HTTP $HTTP_CODE (container may still be starting)..."
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 10
            fi
          done
          
          echo "âŒ Frontend health check failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Deployment summary
        run: |
          echo "### Deployment Successful! ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Backend URL:** ${{ steps.backend-url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend URL:** ${{ steps.frontend-url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**API Docs:** ${{ steps.backend-url.outputs.url }}/docs" >> $GITHUB_STEP_SUMMARY
